imports:
  - import math
  - import random
  - import numpy as np
  - from math import log, sqrt, exp

syntax:
  - rule: L -> E
    weight:
      E: "lambda parent_dif: generator_difficult"

  - rule: E -> S F
    weight:
      S: "lambda parent_dif: parent_dif / 4 if parent_dif > 8 else 2"
      F: "lambda parent_dif, S: parent_dif - S if parent_dif - S > 5 else 0"

  - rule: E -> S F W
    weight:
      S: "lambda parent_dif: parent_dif /5 if parent_dif > 10 else 0"
      F: "lambda parent_dif: parent_dif /3 if parent_dif > 10 else 0"
      W: "lambda parent_dif, S, F: parent_dif - S - F if parent_dif - S - F > 5 else 0"

  - rule: S -> Select A
    weight:
      A: "lambda parent_dif: parent_dif"

  - rule: S -> Select *
    weight: {}

  - rule: F -> From T
    weight:
      T: "lambda parent_dif: parent_dif"

  - rule: F -> From ( E ) As TableName
    weight:
      E: "lambda parent_dif: 0 if get_nested_depth() >= max_nested_depth else parent_dif - 2"

  - rule: W -> Where Z
    weight:
      Z: "lambda parent_dif: parent_dif"

  - rule: A -> Attribute
    weight:
      Attribute: "lambda parent_dif: parent_dif"

  - rule: A -> Attribute, AttributeList
    weight:
      Attribute: "lambda parent_dif: 4"
      AttributeList: "lambda parent_dif: parent_dif - 2 if parent_dif > 0 else 0"

  - rule: AttributeList -> Attribute
    weight:
      Attribute: "lambda parent_dif: parent_dif"

  - rule: T -> Table
    weight:
      Table: "lambda parent_dif: parent_dif"
    actions:
      - Table.details := rand(symbol_table, T.dif, 5, "table")



# 修改WHERE相关规则
  - rule: Z -> Z OR Y
    weight:
      Z: "lambda parent_dif: parent_dif - 4 if parent_dif > 8 and get_nested_depth() < max_nested_depth else 0"
      Y: "lambda parent_dif,Z: parent_dif - Z if parent_dif > 8 and get_nested_depth() < max_nested_depth else 0"


  - rule: Z -> Y
    weight:
      Y: "lambda parent_dif: parent_dif"

  - rule: Y -> Y AND C
    weight:
      Y: "lambda parent_dif: parent_dif - 4 if parent_dif > 8 and get_nested_depth() < max_nested_depth else 0"
      C: "lambda parent_dif,Y: parent_dif - Y if parent_dif > 8 and get_nested_depth() < max_nested_depth else 0"

  - rule: Y -> C
    weight:
      C: "lambda parent_dif: parent_dif"

  - rule: C -> ( Z )
    weight:
      Z: "lambda parent_dif: parent_dif"

  - rule: C -> NOT C
    weight:
      C: "lambda parent_dif: parent_dif - 4 if parent_dif > 8 else 0"

  - rule: C -> P
    weight:
      P: "lambda parent_dif: parent_dif"

  - rule: P -> Attribute O Value
    weight:
      Attribute: "lambda parent_dif: parent_dif - 4 if parent_dif > 0 else 4"
      O: "lambda parent_dif: 2"
      Value: "lambda parent_dif: 2"

  - rule: P -> Attribute O Attribute
    weight:
      Attribute1: "lambda parent_dif: parent_dif - 4 if parent_dif > 0 else 4"
      O: "lambda parent_dif: 2"
      Attribute2: "lambda parent_dif: 2"

  - rule: P -> Attribute = Attribute
    weight:
      Attribute1: "lambda parent_dif: parent_dif - 2 if parent_dif > 0 else 2"
      Attribute2: "lambda parent_dif: parent_dif - 2 if parent_dif > 0 else 2"

  - rule: P -> A IN ( E )
    weight:
      A: "lambda parent_dif: parent_dif / 4 if parent_dif > 10 else 0"
      E: "lambda parent_dif,A: parent_dif - A if parent_dif > 7 else 0"

  - rule: P -> EXISTS ( E )
    weight:
      E: "lambda parent_dif: parent_dif"  # 完全传递难度

# 定义属性部分
columns:
  - name: GPA
    type: LimitedFloat
    params: [1, 1.0, 4.0]
    dif: 2

  - name: Major
    type: CustomString
    params: [20]
    dif: 2

  - name: Location
    type: CustomString
    params: [20]
    dif: 2

  - name: ID
    type: CustomInt
    params: [1000, 9999]
    dif: 2

  - name: Age
    type: CustomInt
    params: [18, 25]
    dif: 2

  - name: Name
    type: CustomString
    params: [10]
    dif: 2

  - name: Unit
    type: UnitFloat
    params: [1.0, 2.0, 3.0, 4.0]
    dif: 2

  - name: Classroom
    type: CustomString
    params: [5]
    dif: 2

  # 新增属性部分
  - name: Subject
    type: CustomString
    params: [20]
    dif: 3

  - name: Salary
    type: LimitedFloat
    params: [3000, 5000, 10000]
    dif: 4

  - name: Experience
    type: CustomInt
    params: [1, 10]
    dif: 3

  - name: Department
    type: CustomString
    params: [15]
    dif: 3


# 定义表格部分
tables:
  - name: Course
    columns: [ID, Name, Unit, Classroom]
    dif: 10

  - name: Student
    columns: [ID, GPA, Age]
    dif: 7

  - name: School
    columns: [Major, Location]
    dif: 5

  # 新增表格：Teacher
  - name: Teacher
    columns: [Name, Subject, Salary, Experience, Department]
    dif: 6

constants:
  - generator_difficult: 20  # 初始难度值
  - threshold: 0.0     # 难度阈值

functions:
  rand:
    implementation: |
      def rand(symbol_table, Table_DOT_dif, tolerance, expected_type):  # 默认值为 "table"
          
          # print(f"Debug: Received parameters -> Table_DOT_dif: {Table_DOT_dif}, tolerance: {tolerance}, expected_type: {expected_type}")

          # 确保参数有效
          #if Table_DOT_dif is None:
          #    raise ValueError("Table_DOT_dif is None")
          #if symbol_table is None:
          #    raise ValueError("symbol_table is None")
          #if expected_type is None:
          #    expected_type = 'table'
          #   # raise ValueError("expected_type is None")

          # 解决浮点误差问题
          if tolerance is None:
              tolerance = 5  # 默认值
          tolerance += 1e-9

          # 使用 difficulty 和类型过滤 symbol_table 中的符号
          filtered_symbols = [
              (name, details) for name, details in symbol_table.symbols.items()
              if details and 'dif' in details and abs(details['dif'] - Table_DOT_dif) <= tolerance and details.get('type') == expected_type
          ]

           print(f"难度： (Table_DOT_dif: {Table_DOT_dif}, 容忍度：: {tolerance}, 期望类型为: {expected_type})可选表为: {filtered_symbols}")

          if not filtered_symbols:
              raise ValueError(f"No matching symbol found with the specified difficulty: {Table_DOT_dif} and type: {expected_type}. Consider adjusting tolerance or checking the type.")

          selected_symbol = random.choice(filtered_symbols)
          return {"此次运行rand函数选择的表名为": selected_symbol[0], "details": selected_symbol[1]}

  check_difficulty:
    implementation: |
      def check_difficulty(current_dif):
          """检查当前难度值是否允许继续展开"""
          if current_dif is None:
              return True
          return float(current_dif) > 1.0  # 设置最小难度阈值为1.0

  # 添加获取简单规则的函数
  get_simple_value:
    implementation: |
      def get_simple_value(symbol_type):
          """当难度值过低时返回简单值"""
          if symbol_type == "table":
              return "SimpleTable"
          return None
